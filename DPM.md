# Notes on DPM

DPM is [presented](http://developer.authorize.net/api/) as an alternative to the other Authorize.Net payment processing integration methods, SIM and AIM. The reality is that DPM is just a special case of SIM.

### SIM and AIM

1. with SIM (simple integration method), browsers POST credit card details directly to the Authorize.Net gateway and receive a response from the gateway.

2. with AIM (advanced integration method), merchant web servers collect the credit card details first, and then POST to the payment processor as an integral part of taking the order. Browser users submit their credit card information to the merchant's web server, and receive a response back from the same server.

From an authentication perspective AIM is actually simpler, because the merchant's secret "transaction key" is just another field sent by the server to the payment processor along with the other details. After the transaction has been processed, the browser receives a "normal" HTTP response from the web server without being exposed to any of the merchant's "back-end" processing details.

From a PCI security perspective however, AIM places a greater compliance burden on the merchant, because all the credit card details have to travel through the merchant's server. This makes it harder (or impossible) to use AIM on servers hosted in shared environments where end-to-end encryption between the browser and the server is not guaranteed.

With SIM, the credit card details do not have to travel through the merchant's web server because they are sent directly to the payment processor. This means however that the HTML form in the browser has to point to the URL of the payment processor and fields have to be named according to Authorize.Net field naming requirements, and it also means that the browser has to send an additional "stamp" which can be verified by the payment processor as coming from the merchant without revealing the merchant's Authorize.Net credentials to the customer. Without this stamp, it would be possible for anyone to submit transactions for payment processing, even if those transactions never originated from the merchant.

The SIM "fingerprint" for each transaction is generated on-demand using an MD5 hash based on a unique unique transaction id, timestamp, and transaction amount and HMAC-authenticated with the merchant's secret key. Since the merchant's credentials have to be kept secret, this computation cannot be deployed onto untrusted machines or run inside customer browsers. This means that the payment processing form cannot be entirely static -- it needs to contain transaction-specific information which can only be generated on a merchant-controlled system. More about the implementation details follows below.

### DPM

DPM is an extension of SIM which relies on a SIM feature called "Relay Response". These are HTML transaction receipts which are generated by a merchant system instead of being generated by the payment processor gateway. After the SIM transaction details have been POSTed from the user's browser directly to the payment processor gateway, the gateway first processes the transaction, and then POSTs the transaction response codes and other details to a "Relay Response" URL provided by the merchant via the merchant interface. It then "relays" or forwards the merchant's response back from this URL back to the browser. Since this page is served as the HTTP response to the payment form POSTed to the Authorize.Net gateway URL, browsers will display this gateway URL in the address bar when they render the response page.

DPM avoids making the payment processor URL visible in the browser address bar. It does this by using a browser redirect embedded in the "Relay Response" content. This tells the browser to go to another URL on the merchant's web site immediately after POSTing to the gateway rather than first rendering the HTML transaction receipt page.

Everything else about DPM is identical to SIM, including the mechanism for generating the transaction-specific fingerprints in the payment form, and the mechanism for handling the "Relay Response" requests originating from the Authorize.Net gateway.

The SIM documentation, FAQ, and developer community can all be leveraged as resources for helping to implement a working DPM integration. (For this reason I think it would have been better, at least in the developer documentation, NOT to position DPM as an alternative to SIM.)

### SIM/DPM Implementation details

Most of this information was gleaned from studying the Authorize.Net [developer documentation](http://developer.authorize.net/).

#### fingerprints

Fingerprints are HMAC authenticated MD5 hashes, not to be confused with normal MD5 hashes. They are included as hidden form fields POSTed to the payment processor gateway. The code for generating these using the [crypto](http://nodejs.org/api/crypto.html) api in node.js is quite straightforward: E.g. (LOGINID and TRANSACTIONKEY refer to credentials from authorize.net)

```javascript
function fingerprint(amount) {
  var data = {
    x_amount: Number(amount.replace(/[$,\s]/g,'')).toFixed(2),  // assumes that amount is a valid number
    x_login: authnet.LOGINID,                                   // from merchant interface
    x_fp_sequence: (Math.random()+'').slice(2,12),              // can be substituted with an order ID string
    x_fp_timestamp: (Date.now()+'').slice(0,-3),                // assumes that system clock is correctly set
    x_relay_url: authnet.RELAYURL
  };
  data.x_fp_hash = crypto.createHmac('md5', authnet.TRANSACTIONKEY) // also from merchant interface
    .update(data.x_login + '^' + data.x_fp_sequence + '^' + data.x_fp_timestamp + '^' + data.x_amount + '^')
    .digest('hex');
  return data;
}
```

The 4 elements which are used to construct the fingerprint will be verified by gateway when the form is POSTed there. The intent is to ensure that the transaction can be traced back to the merchant as the (only) holder of the "Transaction Key". Once the fingerprint is generated, a malicious user should not be able to change any of the 4 values like the amount or orderID prior to submitting the transaction for processing.

All 4 string components have to be included when POSTing the form or else the fingerprint check will fail on the gateway. Here is a jquery function for requesting the fingerprint values and populating the form with the results. In this case the amount is passed from the browser to the /fingerprint generator via a simple HTTP GET. In a production setting, this interface should be restricted so that only merchant website visitors can make the request. E.g.

```javascript
function getFingerprint() {
  $.getJSON( '/fingerprint?amount=' + encodeURIComponent($('#x_amount').val()), function(data) {
    $('#x_fp_hash').val(data.x_fp_hash);
    $('#x_fp_sequence').val(data.x_fp_sequence);
    $('#x_fp_timestamp').val(data.x_fp_timestamp);
    $('#x_login').val(data.x_login);
    $('#x_amount').val(data.x_amount); // overwrite so that field matches string used for fingerprint
    if (!$('#x_relay_url').val()) {
      $('#x_relay_url').val(data.x_relay_url); // populate relay url from fingerprint server if empty
    }
  });
}
```
#### relay response MD5 hash

A similar hash fingerprint is sent from the gateway to the relay response URL. This is a normal MD5 hash (not HMAC) where the input is composed of a secret hash value provided by the merchant through the merchant interface, concatenated with the merchant's login id, a transaction id (generated by the gateway), and the transaction amount. Note that `x_MD5_Hash` is POSTed by the gateway to the relay response URL in upper case. E.g.

```javascript
function transactionMD5(data) {
  if (!data || !data.x_MD5_Hash) return '';
  var s = authnet.MD5HASH + authnet.LOGINID + data.x_trans_id + data.x_amount;
  return crypto.createHash('md5').update(s).digest('hex').toUpperCase();
}
```

#### relay response errors

Validating the fingerprint is performed by the gateway and the transaction will not be processed if the fingerprint is not correct.

Validating the MD5 hash is performed by the server handling the relay response URL, and simply provides a way to ensure that the relay response request was sent from the Authorize.NET gateway and not by some unknown 3rd party. If the relay response server returns an error to the gateway, the gateway will not reject the transaction which has already been processed. Instead it will send a generic message back to the browser saying the following.

> An error occurred while trying to report this transaction to the merchant. An e-mail
> has been sent to the merchant informing them of the error. The following is the result
> of the attempt to charge your credit card.
> 
>   This transaction has been approved.
> 
> It is advisable for you to contact the merchant to verify that you will receive the product or service.

#### correlating POSTed payment transactions with orders

Neither of the 2 hash validation mechanisms above protect against other forms of tampering with order information on the browser side prior to POSTing the transaction. E.g. a user with knowledge of HTML could easily change non-fingerprint fields like the customer ID or invoice number and these changes would be recorded in the transaction by the gateway, and forwarded to the relay response without being automatically detected.

Unfortunately the value of the `x_fp_sequence` field which is part of the original transaction fingerprint is not recorded by the gateway in the transaction details or sent back to the relay response URL. This makes it a little tricky to deal with the kind of tampering described above because merchants cannot simply use `x_fp_sequence` for the order ID, and then lookup the order for processing or validation based on the value in that field when it is returned with the other transaction details.

The workaround is for merchants to compute a 3rd hash based on other important order details included with the payment, and then include 2 copies of that hash value in the payment form: The first in `x_fp_sequence` and the 2nd in some other field which is passed along with the transaction.

Now, after the transaction is processed, the merchant can recompute the hash using just the information from the gateway, to verify that the transaction details recorded by the payment processor are valid. If there is a discrepancy, the merchant can immediately run a (manual or automated) process to reverse the payment and ask the customer to resubmit their information again.

#### more on correlating orders

It turns out (as of Jun, 2014) that values of text fields posted to the gateway may be corrupted in the relay response because the relay reponse cannot handle non-latin utf-8 characters. This means that any text fields (like name and address information) have to be transmitted to the merchant server directly instead of passing through the gateway. This creates a challenge because those details, captured first, have to be matched up with the relay response transaction coming from the gateway.

Since we do not require authenticated user sessions, this solutions depends on customer browsers maintaining a secure anonymous session which is preserved while the payment posts to the gateway. The session is used to maintain order details in memory on the server until the relay response notifies the server with the payment transaction result, at which point the order is processed, emails are sent, etc. Since the order details are stored with the session, only the user who owns that session will have access to their order details e.g. via the thank-you/confirmation page to which they are redirected after posting payment.

Unfortunately, it gets more complicated.

Merchants also rely on confirmation emails sent by Authorize.Net both to the customer and back to the merchant - which include descriptions of what was purchased. These emails are often relied upon to help with returns and refunds, so it is important that the information in them can be trusted.

Unfortunately, because of the way browsers were designed, and the way the SIM/DPM interface operates, it is relatively easy for a nefarious user to tamper with form field values before the information is submitted say to the payment gateway. With SIM/DPM we end up splitting (or duplicating) the information flow between the payment processor and the merchant server. This means that unless we take additional protective measures, someone could tamper with the payment form and introduce product details into the payment processor confirmation emails, which are different from the product details recorded by the merchat server prior to payment.

Ideally we would validate that ALL the order information is consistent between systems, however, because of the Authorize.Net system limitations with utf-8, in this case we are limited to validating fields whose values are always 7-bit ascii like amounts, email adresses, dates, and computer-generated ids.

The way we validate these is by hashing them to generate a unique order ID which is used to store the order in the session and also passed back through the payment processor with the first fingerprint. The fieds in the relay response are then tested to make sure that at least those fields included in the hash function used to generated the order ID, were not modified prior to posting with the payment. Using a hash instead of simply comparing fields allows for the relay response to be verified quickly without necessarily having access to the order in the user's session.

Including session IDs in this way requires special care because of the risk of session "hijacking" and other tricks. Take a scenario of 2 transactions happening in 2 browser sessions belonging to the same nefarious user. One is for $10 and the other is for $1000. An expert user could take the session ID for the large transaction and send that with the payment for the small transaction. Unless this is detected on the back end when the relay response arrives, the merchant may interpret this as a successful payment for the large transaction, even though a much smaller amount was actually processed by the gateway. In our case this scenario is prevented by including the both the session ID and the secret `MD5 hash` string when we generate the order ID.
